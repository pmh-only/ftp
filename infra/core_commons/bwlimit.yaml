apiVersion: v1
kind: ConfigMap
metadata:
  name: bwlimit-script
  namespace: kube-system
data:
  monitor.sh: |
    #!/bin/bash
    set -e

    # Configuration
    THRESHOLD_BYTES=$((30 * 1024 * 1024 * 1024))  # 30GB in bytes
    CHECK_INTERVAL=60
    RESET_HOUR=0  # Reset at midnight UTC
    NFTABLES_SET="banned_ips"
    NFTABLES_TABLE="bwlimit"
    LOG_FILE="/var/log/bwlimit.log"
    STATE_DIR="/var/lib/bwlimit"
    INTERFACE="eth0"  # Change to your mirror server interface (eth0, eth1, etc.)

    mkdir -p "$STATE_DIR"

    # Function to setup nftables rules
    setup_nftables() {
        echo "[$(date)] Setting up nftables..." | tee -a "$LOG_FILE"
        
        # Flush existing rules if table exists
        nft flush table inet "$NFTABLES_TABLE" 2>/dev/null || true
        nft delete table inet "$NFTABLES_TABLE" 2>/dev/null || true
        
        # Create table and chain
        nft create table inet "$NFTABLES_TABLE"
        nft create chain inet "$NFTABLES_TABLE" egress_out { type filter hook output priority 0\; }
        nft create set inet "$NFTABLES_TABLE" "$NFTABLES_SET" { type ipv4_addr\; }
        
        # Block traffic TO banned IPs on egress (TCP and UDP) - mirror server downloads
        nft add rule inet "$NFTABLES_TABLE" egress_out oifname "$INTERFACE" ip daddr @"$NFTABLES_SET" drop
        
        echo "[$(date)] nftables setup complete" | tee -a "$LOG_FILE"
    }

    # Function to get egress bytes per IP using nfstat (netfilter statistics)
    get_egress_stats() {
        local temp_file=$(mktemp)
        
        # Create temporary nftables rule to count bytes per destination IP
        # This is more reliable than conntrack for bandwidth tracking
        nft list ruleset 2>/dev/null | grep -A5 "counter" | awk '
        /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/ {
            ip = $1
            bytes = $NF
            gsub(/[^0-9]/, "", bytes)
            if (ip && bytes > 0) {
                print ip, bytes
            }
        }' > "$temp_file"
        
        # Fallback: use proc net dev if nft fails
        if [[ ! -s "$temp_file" ]]; then
            cat /proc/net/dev 2>/dev/null | awk -v iface="$INTERFACE" '
            $1 ~ iface {
                # Parse interface statistics
                # Fields: RX_bytes RX_packets RX_errs RX_drop RX_fifo RX_frame RX_compressed RX_multicast TX_bytes...
                tx_bytes = $10
                if (tx_bytes > 0) {
                    print "total", tx_bytes
                }
            }' > "$temp_file"
        fi
        
        cat "$temp_file"
        rm -f "$temp_file"
    }

    # Function to check and ban IPs
    check_and_ban() {
        local current_hour=$(date +%H)
        local today=$(date +%Y-%m-%d)
        local state_file="$STATE_DIR/daily_bytes_${today}.db"
        local last_reset_file="$STATE_DIR/last_reset.txt"
        
        # Reset on new day
        local last_reset=$(cat "$last_reset_file" 2>/dev/null || echo "")
        if [[ "$today" != "$last_reset" ]]; then
            echo "[$(date)] New day detected. Resetting counters and unbanning all IPs" | tee -a "$LOG_FILE"
            
            # Remove all banned IPs from nftables
            if nft list set inet "$NFTABLES_TABLE" "$NFTABLES_SET" &>/dev/null; then
                while read -r ip; do
                    [[ -z "$ip" ]] && continue
                    echo "[$(date)] UNBANNING IP: $ip (daily reset)" | tee -a "$LOG_FILE"
                    nft delete element inet "$NFTABLES_TABLE" "$NFTABLES_SET" "{ $ip }" 2>/dev/null || true
                done < <(nft list set inet "$NFTABLES_TABLE" "$NFTABLES_SET" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}')
            fi
            
            # Reset state files
            rm -f "$STATE_DIR"/daily_bytes_*.db
            echo "$today" > "$last_reset_file"
        fi
        
        # Initialize state file if needed
        touch "$state_file"
        
        # Get current stats
        local temp_current=$(mktemp)
        get_egress_stats > "$temp_current"
        
        # Process each IP
        while read -r ip bytes; do
            [[ -z "$ip" ]] && continue
            
            # Skip localhost and internal addresses
            [[ "$ip" == "127.0.0.1" ]] && continue
            [[ "$ip" == "::1" ]] && continue
            [[ "$ip" =~ ^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[01]\.|^192\.168\. ]] && continue
            
            # Read previous count from state file
            local prev_bytes=$(grep "^$ip:" "$state_file" 2>/dev/null | cut -d: -f2 || echo "0")
            local total_bytes=$((prev_bytes + bytes))
            
            # Update state file
            sed -i "/^$ip:/d" "$state_file" 2>/dev/null || true
            echo "$ip:$total_bytes" >> "$state_file"
            
            # Check threshold
            if [[ $total_bytes -gt $THRESHOLD_BYTES ]]; then
                # Check if already banned
                if ! nft get element inet "$NFTABLES_TABLE" "$NFTABLES_SET" "{ $ip }" &>/dev/null; then
                    echo "[$(date)] BANNING IP: $ip (${total_bytes} bytes)" | tee -a "$LOG_FILE"
                    nft add element inet "$NFTABLES_TABLE" "$NFTABLES_SET" "{ $ip }"
                fi
            fi
        done < "$temp_current"
        
        rm -f "$temp_current"
    }

    # Main loop
    echo "[$(date)] Starting egress monitor..." | tee -a "$LOG_FILE"
    setup_nftables

    while true; do
        check_and_ban
        sleep "$CHECK_INTERVAL"
    done

  unban.sh: |
    #!/bin/bash
    # Script to manually unban an IP
    # Usage: ./unban.sh <IP>

    IP=$1
    NFTABLES_TABLE="bwlimit"
    NFTABLES_SET="banned_ips"

    if [[ -z "$IP" ]]; then
        echo "Usage: $0 <IP>"
        exit 1
    fi

    echo "Unbanning IP: $IP"
    nft delete element inet "$NFTABLES_TABLE" "$NFTABLES_SET" "{ $IP }" 2>/dev/null && echo "Success" || echo "Failed or IP not found"

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: bwlimit
  namespace: kube-system
spec:
  selector:
    matchLabels:
      app: bwlimit
  template:
    metadata:
      labels:
        app: bwlimit
    spec:
      hostNetwork: true
      hostPID: true
      dnsPolicy: ClusterFirstWithHostNet
      priorityClassName: system-node-critical
      tolerations:
        - operator: Exists
          effect: NoSchedule
        - operator: Exists
          effect: NoExecute
      containers:
        - name: monitor
          image: alpine:latest
          securityContext:
            privileged: true
            capabilities:
              add:
                - NET_ADMIN
                - SYS_ADMIN
          volumeMounts:
            - name: script
              mountPath: /scripts
            - name: logs
              mountPath: /var/log
            - name: state
              mountPath: /var/lib/bwlimit
            - name: sys
              mountPath: /sys
            - name: proc
              mountPath: /proc
          command:
            - /bin/sh
            - -c
            - |
              apk add --no-cache nftables conntrack-tools curl bash
              chmod +x /scripts/*.sh
              exec /scripts/monitor.sh
          resources:
            requests:
              memory: "256Mi"
              cpu: "200m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            exec:
              command:
                - sh
                - -c
                - ps aux | grep -q '[m]onitor.sh'
            initialDelaySeconds: 30
            periodSeconds: 30
      volumes:
        - name: script
          configMap:
            name: bwlimit-script
            defaultMode: 0755
        - name: logs
          hostPath:
            path: /var/log/bwlimit
            type: DirectoryOrCreate
        - name: state
          hostPath:
            path: /var/lib/bwlimit
            type: DirectoryOrCreate
        - name: sys
          hostPath:
            path: /sys
        - name: proc
          hostPath:
            path: /proc
