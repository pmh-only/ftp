apiVersion: v1
kind: ConfigMap
metadata:
  name: bwlimit-script
  namespace: kube-system
data:
  bwlimit.sh: |
    #!/bin/bash
    set -e

    # Configuration
    LIMIT_BYTES=$((5 * 1024 * 1024 * 1024))  # 5GB in bytes
    INTERFACE="enp0s6"  # Monitor only this interface
    STATE_FILE="/var/lib/bwlimit/state.txt"
    IP_BYTES_DIR="/var/lib/bwlimit/ip_bytes"

    mkdir -p /var/lib/bwlimit
    mkdir -p "$IP_BYTES_DIR"

    # Check if IP is private
    is_private_ip() {
      local ip=$1
      case $ip in
        10.*|172.16.*|172.17.*|172.18.*|172.19.*|172.20.*|172.21.*|172.22.*|172.23.*|172.24.*|172.25.*|172.26.*|172.27.*|172.28.*|172.29.*|172.30.*|172.31.*|192.168.*)
          return 0
          ;;
        *)
          return 1
          ;;
      esac
    }

    # Initialize nftables for blocking
    init_firewall() {
      echo "Initializing firewall rules..."

      # Create table and set for banned IPs
      nft add table inet bwlimit 2>/dev/null || true
      nft flush table inet bwlimit 2>/dev/null || true
      nft add chain inet bwlimit output { type filter hook output priority 0 \; }
      nft add set inet bwlimit banned { type ipv4_addr \; }

      # Drop traffic to banned IPs on the interface
      nft add rule inet bwlimit output oifname "$INTERFACE" ip daddr @banned counter drop

      echo "Firewall initialized for interface $INTERFACE"
    }

    # Ban an IP
    ban_ip() {
      local ip=$1
      local bytes=$2
      local gb=$(echo "scale=2; $bytes / 1024 / 1024 / 1024" | bc)

      echo "$(date): IP $ip exceeded limit with ${gb}GB. Banning..."
      nft add element inet bwlimit banned { "$ip" } 2>/dev/null || true
      echo "$(date): Banned $ip (${gb}GB)" >> "$STATE_FILE"
    }

    # Get total bytes for an IP
    get_ip_bytes() {
      local ip=$1
      local file="$IP_BYTES_DIR/${ip}.bytes"
      if [ -f "$file" ]; then
        cat "$file"
      else
        echo "0"
      fi
    }

    # Add bytes to IP total
    add_ip_bytes() {
      local ip=$1
      local bytes=$2
      local file="$IP_BYTES_DIR/${ip}.bytes"

      local current=$(get_ip_bytes "$ip")
      local new_total=$((current + bytes))
      echo "$new_total" > "$file"
      echo "$new_total"
    }

    # Check if IP is banned
    is_banned() {
      local ip=$1
      nft list set inet bwlimit banned 2>/dev/null | grep -q "$ip"
    }

    # Monitor traffic and track bytes
    monitor_traffic() {
      echo "Starting traffic monitoring on $INTERFACE..."
      echo "tcpdump filter: (tcp or udp) and dst net not (10.0.0.0/8 or 172.16.0.0/12 or 192.168.0.0/16)"

      local packet_count=0

      # Use tcpdump to capture packet sizes (not content, just headers)
      # -i: interface
      # -n: don't resolve names
      # -l: line buffered
      # -tt: timestamp (not using -q to get full output with length)
      # Filter: outgoing TCP/UDP, not to private IPs
      tcpdump -i "$INTERFACE" -n -l -tt \
        '(tcp or udp) and dst net not (10.0.0.0/8 or 172.16.0.0/12 or 192.168.0.0/16)' \
        2>/dev/null | while read -r line; do

        packet_count=$((packet_count + 1))

        # Parse tcpdump output to get destination IP and packet length
        # Format: timestamp IP src.port > dst.port: ... length NNNN
        # Extract destination IP (between > and : or .)
        local dst_ip=$(echo "$line" | awk '{for(i=1;i<=NF;i++) if($i==">") print $(i+1)}' | cut -d. -f1-4 | cut -d: -f1)

        # Extract length field
        local length=$(echo "$line" | awk '{for(i=1;i<=NF;i++) if($i=="length") print $(i+1)}' | sed 's/[^0-9]//g')

        # Debug first 10 packets to see parsing
        if [ $packet_count -le 10 ]; then
          echo "DEBUG: Packet $packet_count - IP: '$dst_ip' Length: '$length'"
          echo "       Line: $line"
        fi

        # Debug every 1000 packets
        if [ $((packet_count % 1000)) -eq 0 ]; then
          echo "Processed $packet_count packets..."
        fi

        if [ -n "$dst_ip" ] && [ -n "$length" ] && [ "$length" -gt 0 ]; then
          # Skip if already banned
          is_banned "$dst_ip" && continue

          # Add bytes to IP total
          local new_total=$(add_ip_bytes "$dst_ip" "$length")

          # Log significant additions
          if [ $((packet_count % 100)) -eq 0 ]; then
            local gb=$(echo "scale=3; $new_total / 1024 / 1024 / 1024" | bc)
            echo "IP $dst_ip: ${gb}GB total"
          fi

          # Check if exceeded limit
          if [ "$new_total" -gt "$LIMIT_BYTES" ]; then
            ban_ip "$dst_ip" "$new_total"
          fi
        fi
      done
    }

    # Reset all counters and bans
    reset_daily() {
      echo "Resetting daily limits at $(date)"

      # Flush banned IPs
      nft flush set inet bwlimit banned 2>/dev/null || true

      # Clear all tracking files
      rm -rf "$IP_BYTES_DIR"
      mkdir -p "$IP_BYTES_DIR"

      # Clear state file
      > "$STATE_FILE"

      echo "Reset complete"
    }

    # Show current status
    show_status() {
      echo "=== Bandwidth Limit Status ==="
      echo "Current time: $(date)"
      echo "Interface: $INTERFACE"
      echo "Limit: $(($LIMIT_BYTES / 1024 / 1024 / 1024))GB per day"
      echo "Excluding: Private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)"
      echo ""
      echo "Banned IPs:"
      nft list set inet bwlimit banned 2>/dev/null | grep "elements" || echo "  None"
      echo ""
      echo "Top bandwidth users:"

      # Read all byte tracking files
      for file in "$IP_BYTES_DIR"/*.bytes; do
        if [ -f "$file" ]; then
          local ip=$(basename "$file" .bytes)
          local bytes=$(cat "$file")
          if [ "$bytes" -gt 0 ]; then
            local gb=$(echo "scale=2; $bytes / 1024 / 1024 / 1024" | bc)
            echo "$ip:$gb"
          fi
        fi
      done | sort -t: -k2 -rn | head -20 | while IFS=: read -r ip gb; do
        echo "  $ip: ${gb}GB"
      done
    }

    # Check if it's midnight (00:00)
    should_reset() {
      local current_time=$(date +"%H:%M")
      [ "$current_time" = "00:00" ] && return 0
      return 1
    }

    # Main function
    main() {
      echo "Starting bandwidth limiter for package mirror server..."
      echo "Monitoring interface: $INTERFACE"
      echo "Limit: $(($LIMIT_BYTES / 1024 / 1024 / 1024))GB per day"
      echo "Excluding private IP ranges: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16"

      # Initialize firewall
      init_firewall

      # Start status reporter in background
      (
        while true; do
          sleep 60  # Every 1 minutes
          show_status
        done
      ) &
      local status_pid=$!

      # Start daily reset checker in background
      (
        local last_reset_date=""
        while true; do
          local current_date=$(date +"%Y-%m-%d")
          if [ "$last_reset_date" != "$current_date" ] && should_reset; then
            reset_daily
            last_reset_date="$current_date"
            sleep 60  # Sleep for a minute to avoid multiple resets
          fi
          sleep 30  # Check every 30 seconds
        done
      ) &
      local reset_pid=$!

      # Monitor traffic (blocking call)
      monitor_traffic

      # Cleanup (if monitor_traffic exits)
      kill $status_pid $reset_pid 2>/dev/null || true
    }

    # Handle signals
    trap 'echo "Shutting down..."; exit 0' SIGTERM SIGINT

    # Run
    main

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: bwlimit
  namespace: kube-system
  labels:
    app: bwlimit
spec:
  selector:
    matchLabels:
      app: bwlimit
  template:
    metadata:
      labels:
        app: bwlimit
    spec:
      hostNetwork: true
      hostPID: true
      containers:
        - name: bwlimit
          image: alpine:latest
          command:
            - /bin/sh
            - -c
            - |
              apk add --no-cache nftables bash bc tcpdump
              chmod +x /scripts/bwlimit.sh
              exec /scripts/bwlimit.sh
          securityContext:
            privileged: true
            capabilities:
              add:
                - NET_ADMIN
                - NET_RAW
                - SYS_ADMIN
          volumeMounts:
            - name: scripts
              mountPath: /scripts
            - name: state
              mountPath: /var/lib/bwlimit
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "1000m"
      volumes:
        - name: scripts
          configMap:
            name: bwlimit-script
            defaultMode: 0755
        - name: state
          hostPath:
            path: /var/lib/bwlimit
            type: DirectoryOrCreate
      tolerations:
        - effect: NoSchedule
          operator: Exists
