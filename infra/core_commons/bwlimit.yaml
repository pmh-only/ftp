apiVersion: v1
kind: ConfigMap
metadata:
  name: bwlimit-script
  namespace: kube-system
data:
  bwlimit.sh: |
    #!/bin/bash
    set -e

    # Configuration
    LIMIT_BYTES=$((5 * 1024 * 1024 * 1024))  # 5GB in bytes
    CHECK_INTERVAL=60  # Check every 60 seconds
    STATE_FILE="/var/lib/bwlimit/state.txt"
    INTERFACE="enp0s6"  # Monitor only this interface

    mkdir -p /var/lib/bwlimit

    # Initialize nftables
    init_nftables() {
      echo "Initializing nftables rules..."

      # Create table and chains
      nft add table inet bwlimit 2>/dev/null || true
      nft flush table inet bwlimit 2>/dev/null || true

      # Create chains
      nft add chain inet bwlimit track_egress { type filter hook postrouting priority 0 \; }
      nft add chain inet bwlimit banned_ips

      # Create map for tracking bytes per IP
      nft add map inet bwlimit ip_bytes { type ipv4_addr : counter \; }

      # Create set for banned IPs
      nft add set inet bwlimit banned { type ipv4_addr \; }

      # Create set for private IP ranges (to exclude from tracking)
      nft add set inet bwlimit private_ips { type ipv4_addr \; flags interval \; }
      nft add element inet bwlimit private_ips { 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 }

      # Drop traffic to banned IPs (only on enp0s6 interface)
      nft add rule inet bwlimit track_egress oifname "$INTERFACE" ip daddr @banned counter drop

      # Skip private IP addresses (do not count)
      nft add rule inet bwlimit track_egress oifname "$INTERFACE" ip daddr @private_ips counter return

      # Track egress traffic (TCP and UDP) - only on enp0s6 interface, excluding private IPs
      nft add rule inet bwlimit track_egress oifname "$INTERFACE" meta l4proto { tcp, udp } counter update @ip_bytes { ip daddr counter }

      echo "nftables initialized for interface $INTERFACE (excluding private IPs)"
    }

    # Get current hour and minute
    get_current_time() {
      date +"%H:%M"
    }

    # Check if it's midnight (00:00)
    is_midnight() {
      local current_time=$(get_current_time)
      if [ "$current_time" = "00:00" ]; then
        return 0
      fi
      return 1
    }

    # Reset all counters and bans
    reset_daily() {
      echo "Resetting daily limits at $(date)"

      # Flush banned IPs
      nft flush set inet bwlimit banned 2>/dev/null || true

      # Recreate the map to reset counters
      nft delete map inet bwlimit ip_bytes 2>/dev/null || true
      nft add map inet bwlimit ip_bytes { type ipv4_addr : counter \; }

      # Clear state file
      > "$STATE_FILE"

      echo "Reset complete"
    }

    # Check bandwidth usage and ban if needed
    check_and_ban() {
      # Get all IPs and their byte counts
      local nft_output=$(nft list map inet bwlimit ip_bytes 2>/dev/null)

      # Parse the output to extract IP and bytes
      echo "$nft_output" | grep -oP '\d+\.\d+\.\d+\.\d+ : counter packets \d+ bytes \d+' | while read -r line; do
        local ip=$(echo "$line" | grep -oP '^\d+\.\d+\.\d+\.\d+')
        local bytes=$(echo "$line" | grep -oP 'bytes \K\d+')

        if [ -n "$ip" ] && [ -n "$bytes" ]; then
          # Check if already banned
          if nft list set inet bwlimit banned 2>/dev/null | grep -q "$ip"; then
            continue
          fi

          # Check if exceeded limit
          if [ "$bytes" -gt "$LIMIT_BYTES" ]; then
            echo "$(date): IP $ip exceeded limit with $bytes bytes ($(($bytes / 1024 / 1024 / 1024))GB). Banning..."
            nft add element inet bwlimit banned { "$ip" }
            echo "$(date): Banned $ip" >> "$STATE_FILE"
          fi
        fi
      done
    }

    # Show current status
    show_status() {
      echo "=== Bandwidth Limit Status ==="
      echo "Current time: $(date)"
      echo "Interface: $INTERFACE"
      echo "Limit: $(($LIMIT_BYTES / 1024 / 1024 / 1024))GB per day"
      echo "Excluding: Private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)"
      echo ""
      echo "Banned IPs:"
      nft list set inet bwlimit banned 2>/dev/null | grep "elements" || echo "None"
      echo ""
      echo "Top bandwidth users:"
      nft list map inet bwlimit ip_bytes 2>/dev/null | grep -oP '\d+\.\d+\.\d+\.\d+ : counter packets \d+ bytes \d+' | while read -r line; do
        local ip=$(echo "$line" | grep -oP '^\d+\.\d+\.\d+\.\d+')
        local bytes=$(echo "$line" | grep -oP 'bytes \K\d+')
        if [ -n "$ip" ] && [ -n "$bytes" ] && [ "$bytes" -gt 0 ]; then
          local gb=$(echo "scale=2; $bytes / 1024 / 1024 / 1024" | bc)
          echo "  $ip: ${gb}GB"
        fi
      done | sort -t: -k2 -rn | head -20
    }

    # Main loop
    main() {
      echo "Starting bandwidth limiter for package mirror server..."
      echo "Monitoring interface: $INTERFACE"
      echo "Limit: $(($LIMIT_BYTES / 1024 / 1024 / 1024))GB per day"
      echo "Excluding private IP ranges: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16"

      # Initialize
      init_nftables

      # Track if we already reset today
      local last_reset=""

      while true; do
        local current_date=$(date +"%Y-%m-%d")

        # Check if it's a new day and we haven't reset yet
        if [ "$last_reset" != "$current_date" ] && is_midnight; then
          reset_daily
          last_reset="$current_date"
          sleep 60  # Sleep for a minute to avoid multiple resets
          continue
        fi

        # If it's a new day but not midnight yet, update last_reset
        if [ "$last_reset" != "$current_date" ] && [ "$(date +%H)" = "00" ]; then
          # We're in the first hour of a new day
          if [ -z "$last_reset" ]; then
            # First run, consider it reset
            last_reset="$current_date"
          fi
        fi

        # Check bandwidth and ban if needed
        check_and_ban

        # Show status every 10 minutes
        if [ $(($(date +%s) % 600)) -lt $CHECK_INTERVAL ]; then
          show_status
        fi

        sleep $CHECK_INTERVAL
      done
    }

    # Handle signals
    trap 'echo "Shutting down..."; exit 0' SIGTERM SIGINT

    # Run
    main

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: bwlimit
  namespace: kube-system
  labels:
    app: bwlimit
spec:
  selector:
    matchLabels:
      app: bwlimit
  template:
    metadata:
      labels:
        app: bwlimit
    spec:
      hostNetwork: true
      hostPID: true
      containers:
        - name: bwlimit
          image: alpine:latest
          command:
            - /bin/sh
            - -c
            - |
              apk add --no-cache nftables bash bc
              chmod +x /scripts/bwlimit.sh
              exec /scripts/bwlimit.sh
          securityContext:
            privileged: true
            capabilities:
              add:
                - NET_ADMIN
                - NET_RAW
                - SYS_ADMIN
          volumeMounts:
            - name: scripts
              mountPath: /scripts
            - name: state
              mountPath: /var/lib/bwlimit
          resources:
            requests:
              memory: "64Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
      volumes:
        - name: scripts
          configMap:
            name: bwlimit-script
            defaultMode: 0755
        - name: state
          hostPath:
            path: /var/lib/bwlimit
            type: DirectoryOrCreate
      tolerations:
        - effect: NoSchedule
          operator: Exists
